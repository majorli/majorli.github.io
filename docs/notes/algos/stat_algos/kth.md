# k位数与中位数

此处所述k位数，指一个序列中第k小的数。

给定序列 $A[0:n]$，非负整数 $0 \le k \lt n$，若对 $A[0:n]$ 进行升序排序，则k位数等于排完序后的 $A[k-1]$。

此处所述中位数，指统计意义上的中位数，即能将序列分为元素数量相等的前后两部分，使得前一部分的所有数小于等于中位数，后一部分的所有数大于等于中位数的那个数。

给定序列 $A[0:n]$，若对其进行升序排序，则中位数等于：

$$
median=\begin{cases}
A[k-1]&,n=2k-1\\
(A[k-1]+A[k])/2&,n=2k
\end{cases},k=1,2,\dots
$$

现要在不排序的条件下，以比排序更快的速度获取k位数和中位数。

## 序列分区

序列分区是快速排序的基本操作，可用来实现快速地k位数和中位数算法。

**目标：**在序列中选择一个元素作为基准，以该基准值为中心将序列分为前后两部分，前一部分所有元素小于等于基准值，后一部分所有元素大于等于基准值。

序列分区有两种常见方法，一种为基于选择的分区，中文网站和教程较为常用此方法；另一种为基于冒泡的分区，《算法导论》一书使用该方法，国外网站和教程较为常用此方法。二者都完成对子序列 $A[l:r]$ 进行分区的操作，并返回分区后基准值元素所在的位置 $p$。

### 基于选择的序列分区

给定子序列 $A[l:r]$，使用首元素为基准进行分区。分区时，先从右向左扫描寻找第一个小于基准值的元素，并将其交换到序列前部，然后从左到右扫描第一个大于等于基准值的元素并将其交换到序列后部，如此不断循环直到整个序列扫描完毕。

此算法在网上和算法教程中随处可见，此处不再详细描述，下面是算法的伪码。

时间复杂度 $O(n)$，空间复杂度 $O(1)$。

**算法伪码**

!!! abstract "Algorithm: Partition by Selection"
    // $A$：待分区序列；$l, r$：子序列左右端点，左闭右开

    $\text{PartitionBySelection}(A, l, r):$

    $\ \ \ \ \ \ \ \ pivot \leftarrow A[l],i\leftarrow l,j\leftarrow r-1$

    $\ \ \ \ \ \ \ \ \text{WHILE}\ \ i \lt j\ \ \text{DO}:$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{WHILE}\ \ i \lt j\ \ \text{and}\ \ A[j] \ge pivot\ \ \text{DO}\ \ j \leftarrow j-1$ 

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{IF}\ \ i \lt j\ \ \text{THEN}\ \ A[i] \leftarrow A[j], i \leftarrow i+1$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{WHILE}\ \ i \lt j\ \ \text{and}\ \ A[i] \lt pivot\ \ \text{DO}\ \ i \leftarrow i+1$ 

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{IF}\ \ i \lt j\ \ \text{THEN}\ \ A[j] \leftarrow A[i], j \leftarrow j-1$

    $\ \ \ \ \ \ \ \ A[i]\leftarrow pivot$

    $\ \ \ \ \ \ \ \ \text{RETURN}\ \ i$


### 基于冒泡的序列分区

给定子序列 $A[l:r]$，使用尾元素为基准进行分区。分区时将整个子序列分为三部分，从左到右依次为小于基准值的部分、大于基准值的部分和尚未划分的部分。初始时前两部分长度均为0，随后从左到右扫描第三部分中的每一个元素并根据其值划分到应在的部分中去。

此算法在网上和算法教程中随处可见，此处不再详细描述，下面是算法的伪码。

时间复杂度 $O(n)$，空间复杂度 $O(1)$。

**算法伪码**

!!! abstract "Algorithm: Partition by Bubble"
    // $A$：待分区序列；$l, r$：子序列左右端点，左闭右开

    $\text{PartitionByBubble}(A,l,r):$

    $\ \ \ \ \ \ \ \ i\leftarrow l,last\leftarrow r-1,pivot\leftarrow A[last]$

    $\ \ \ \ \ \ \ \ \text{FOR}\ \ j \leftarrow i\ \ \text{TO}\ \ last-1\ \ \text{DO}:$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{IF}\ \  A[j] \lt pivot\ \ \text{THEN}\ \ \text{Swap}(A[i],A[j]),i\leftarrow i+1$

    $\ \ \ \ \ \ \ \ A[last]\leftarrow A[i]$

    $\ \ \ \ \ \ \ \ A[i]\leftarrow pivot$

    $\ \ \ \ \ \ \ \ \text{RETURN}\ \ i$


## 分区k位数算法

**目标：**快速求出给定序列的k位数。

算法标签：``统计`` ``k位数`` ``高效率`` ``分治``

利用分区的方法可以快速求出给定序列 $A[l:r]$ 的k位数，即第k小的数。k从1开始计数，1位数即序列中最小的数。此处的分区可以采用基于选择的分区方法，也可以采用基于冒泡的分区方法，二者并无区别。此处以采用基于选择的分区描述本算法。

对序列 $A[l:r]$ 进行一次分区，将序列在位置 $p_1$ 处分为 $A[l:p_1]$ 和 $A[p_1+1:r]$ 前后两个子序列。此时：

1. 若 $p_1-1 = k-1$ 则说明分区间断位置处的元素 $A[p_1]$ 即为要求的k位数；
2. 若 $p_1-1 \lt k-1$，说明k位数在后一个子序列 $A[p_1+1:n]$ 中，应递归地在此子序列中继续尝试分区；
3. 若 $p_1-1 \gt k-1$ 则说明k位数在前一个子序列 $A[0:p_1]$ 中，应在此子序列中递归尝试进一步分区。

如此递归，直至某次分区得到的间断位置 $p_i-l=k-1$，次位置处的元素 $A[p_i]$ 即为所求的k位数。此递归过程必能终止，可用循环结构完成递归。

和快速排序一样，凡是基于序列分区的算法都有平均情况和最差情况。平均情况下，每次分区的间断位置都恰在待分区序列的中间，故子问题不断减半，算法工作量的上界为：

$$
W_{avg}(n)=O(n+{n\over2}+{n\over4}+\cdots+1)=O(2n-1)
$$

若出现最差情况，即序列 $A[0:n]$ 本身有序，则每次分区的间断点都在头部（或尾部），于是算法退化为蛮力求解k位数的情况，工作量为：

$$
W_{wst}(n)=(n-1)+(n-2)+\cdots+(n-k)=kn-\frac{k(k+1)}{2}
$$

同样地，和快速排序一样，可以通过pivot随机化来规避最差情况，使得算法的平均工作量趋同为 $O(2n-1)$。

时间复杂度 $O(n)$，空间复杂度 $O(1)$。

**算法伪码**

!!! abstract "kth number by partition"
    // $A$：原序列；$l,r$：序列左右端点；$k$：位数，$1 \le k \le r-l$

    $\text{kthNumberByPartition}(A,l,r,k):$

    $\ \ \ \ \ \ \ \ \text{WHILE}\ \ \text{true}\ \ \text{DO}:$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pivot \leftarrow \text{Random}(l,r-1)$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{Swap}(A[l],A[pivot])$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ p \leftarrow \text{PartitionBySelection}(A,l,r)$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{IF}\ \ p-l = k-1\ \ \text{THEN}\ \ \text{RETURN}\ \ A[p]$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{ELSE}\ \ \text{IF}\ \ p-l \lt k-1\ \ \text{THEN}\ \ l \leftarrow p+1$

    $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{ELSE}\ \ r \leftarrow p$

若采用基于冒泡的分区方法，则在随机选择 $pivot$ 后，应改为将其和尾部元素交换。

事实上，此算法可以不返回任何值，运行结束时k位数必为 $A[l+k-1]$。


## 分区中位数算法

## 锦标赛算法

## 两个有序序列的中位数

### 模拟归并

### 二分查找
